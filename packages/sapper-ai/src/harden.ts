import { existsSync } from 'node:fs'
import { homedir } from 'node:os'
import { join, resolve } from 'node:path'
import * as readline from 'node:readline'

import pkg from '../package.json'

import { renderPolicyYaml } from './policyYaml'
import { atomicWriteFile } from './utils/fs'
import { getInteractivePromptState } from './utils/interactive'
import { findRepoRoot } from './utils/repoRoot'
import { isSemver } from './utils/semver'

import { checkNpxAvailable, resolveInstalledPackageVersion, wrapMcpConfigFile } from './mcp/wrapConfig'

type HardenScope = 'project' | 'system'

interface HardenAction {
  id: string
  scope: HardenScope
  title: string
  paths: string[]
  apply: () => Promise<{ changed: boolean; note?: string }>
}

export interface HardenPlanSummary {
  repoRoot: string
  notes: string[]
  actions: Array<{
    id: string
    scope: HardenScope
    title: string
    paths: string[]
  }>
}

export interface HardenOptions {
  cwd?: string
  env?: NodeJS.ProcessEnv
  includeSystem?: boolean
  dryRun?: boolean
  apply?: boolean
  yes?: boolean
  noPrompt?: boolean
  force?: boolean
  workflowVersion?: string
  mcpVersion?: string
  write?: (text: string) => void
}

function isInteractivePromptAllowed(options: HardenOptions): boolean {
  return getInteractivePromptState({ noPrompt: options.noPrompt, env: options.env }).allowed
}

async function promptYesNo(question: string, defaultYes: boolean): Promise<boolean> {
  const rl = readline.createInterface({ input: process.stdin, output: process.stdout })
  const suffix = defaultYes ? ' [Y/n] ' : ' [y/N] '

  const answer = await new Promise<string>((res) => rl.question(`${question}${suffix}`, res))
  rl.close()

  const normalized = answer.trim().toLowerCase()
  if (!normalized) return defaultYes
  if (normalized === 'y' || normalized === 'yes') return true
  if (normalized === 'n' || normalized === 'no') return false
  return defaultYes
}

function getWorkflowVersion(options: HardenOptions): string | null {
  const fromFlag = options.workflowVersion?.trim()
  const fromEnv = options.env?.SAPPERAI_WORKFLOW_VERSION?.trim()
  const candidate = fromFlag || fromEnv || (typeof pkg.version === 'string' ? pkg.version : '')
  return isSemver(candidate) ? candidate : null
}

function getMcpVersion(options: HardenOptions): string | null {
  const fromFlag = options.mcpVersion?.trim()
  const fromEnv = options.env?.SAPPERAI_MCP_VERSION?.trim()
  const candidate = fromFlag || fromEnv || resolveInstalledPackageVersion('@sapper-ai/mcp') || ''
  return isSemver(candidate) ? candidate : null
}

function buildWorkflowYaml(version: string): string {
  return (
    [
      'name: SapperAI Scan',
      '',
      'on:',
      '  push:',
      '  pull_request:',
      '',
      'jobs:',
      '  scan:',
      '    runs-on: ubuntu-latest',
      '    steps:',
      '      - uses: actions/checkout@v4',
      '      - uses: actions/setup-node@v4',
      '        with:',
      "          node-version: '20'",
      '      - name: SapperAI Scan',
      `        run: npx -y sapper-ai@${version} scan --policy ./sapperai.config.yaml --no-prompt --no-open --no-save`,
      '',
    ].join('\n') + '\n'
  )
}

async function planActions(options: HardenOptions): Promise<{ actions: HardenAction[]; notes: string[]; repoRoot: string }> {
  const cwd = options.cwd ?? process.cwd()
  const env = options.env ?? process.env

  const repoRoot = findRepoRoot(cwd)
  const notes: string[] = []

  const workflowVersion = getWorkflowVersion({ ...options, env })
  if (!workflowVersion) {
    notes.push('Workflow version is unavailable (expected semver). Skipping CI workflow generation.')
  }

  const npxAvailable = checkNpxAvailable()
  if (!npxAvailable) {
    notes.push("npx is not available on PATH. Skipping MCP config wrapping.")
  }

  const mcpVersion = getMcpVersion({ ...options, env })
  if (!mcpVersion) {
    notes.push('MCP version is unavailable (expected semver). Skipping MCP config wrapping.')
  }

  const actions: HardenAction[] = []

  const policyPathYaml = join(repoRoot, 'sapperai.config.yaml')
  const policyPathYml = join(repoRoot, 'sapperai.config.yml')
  if (!existsSync(policyPathYaml) && !existsSync(policyPathYml)) {
    actions.push({
      id: 'project.policy',
      scope: 'project',
      title: 'Create project policy (sapperai.config.yaml)',
      paths: [policyPathYaml],
      apply: async () => {
        const header = ['# SapperAI Configuration', '# Generated by: sapper-ai harden', ''].join('\n') + '\n'
        await atomicWriteFile(policyPathYaml, header + renderPolicyYaml('standard'))
        return { changed: true }
      },
    })
  }

  const workflowPath = join(repoRoot, '.github', 'workflows', 'sapperai.yml')
  if (!existsSync(workflowPath) && workflowVersion) {
    actions.push({
      id: 'project.ci_workflow',
      scope: 'project',
      title: 'Add GitHub Actions scan workflow (.github/workflows/sapperai.yml)',
      paths: [workflowPath],
      apply: async () => {
        await atomicWriteFile(workflowPath, buildWorkflowYaml(workflowVersion))
        return { changed: true }
      },
    })
  }

  const includeSystem = options.includeSystem === true
  if (includeSystem) {
    const home = homedir()

    const globalPolicyPath = join(home, '.sapperai', 'policy.yaml')
    if (!existsSync(globalPolicyPath)) {
      actions.push({
        id: 'system.global_policy',
        scope: 'system',
        title: 'Create global policy (~/.sapperai/policy.yaml)',
        paths: [globalPolicyPath],
        apply: async () => {
          const header = ['# SapperAI Global Policy', '# Generated by: sapper-ai harden', ''].join('\n') + '\n'
          await atomicWriteFile(globalPolicyPath, header + renderPolicyYaml('standard'))
          return { changed: true }
        },
      })
    }

    const claudeConfigPath = join(home, '.config', 'claude-code', 'config.json')
    if (existsSync(claudeConfigPath) && npxAvailable && mcpVersion) {
      let preview: { changed: boolean; changedServers: string[] } | null = null
      try {
        preview = await wrapMcpConfigFile({
          filePath: claudeConfigPath,
          mcpVersion,
          format: 'jsonc',
          dryRun: true,
        })
      } catch (error) {
        const msg = error instanceof Error ? error.message : String(error)
        notes.push(`Failed to parse Claude Code config for MCP wrapping. path=${claudeConfigPath} error=${msg}`)
      }

      if (preview?.changed) {
        actions.push({
          id: 'system.mcp_wrap_claude',
          scope: 'system',
          title: 'Wrap Claude Code MCP servers with sapperai-proxy (~/.config/claude-code/config.json)',
          paths: [claudeConfigPath],
          apply: async () => {
            const result = await wrapMcpConfigFile({
              filePath: claudeConfigPath,
              mcpVersion,
              format: 'jsonc',
            })
            return { changed: result.changed, note: result.backupPath ? `Backup: ${result.backupPath}` : undefined }
          },
        })
      }
    } else if (existsSync(claudeConfigPath) && (!npxAvailable || !mcpVersion)) {
      notes.push('Claude Code config found, but MCP wrapping prerequisites are missing. Provide --mcp-version and ensure npx exists.')
    }
  }

  // Deterministic ordering for readability and testability.
  const scopeOrder: Record<HardenScope, number> = { project: 0, system: 1 }
  actions.sort((a, b) => {
    const diff = scopeOrder[a.scope] - scopeOrder[b.scope]
    if (diff !== 0) return diff
    return a.id.localeCompare(b.id)
  })

  return { actions, notes, repoRoot: resolve(repoRoot) }
}

export async function getHardenPlanSummary(options: HardenOptions = {}): Promise<HardenPlanSummary> {
  const { actions, notes, repoRoot } = await planActions(options)
  return {
    repoRoot,
    notes,
    actions: actions.map((a) => ({ id: a.id, scope: a.scope, title: a.title, paths: a.paths.slice() })),
  }
}

export async function runHarden(options: HardenOptions = {}): Promise<number> {
  const env = options.env ?? process.env
  const write = options.write ?? ((text: string) => process.stdout.write(text))

  const { actions, notes, repoRoot } = await planActions({ ...options, env })

  write('\n  SapperAI Hardening\n\n')
  write(`  Repo root: ${repoRoot}\n`)

  if (actions.length === 0) {
    write('\n  No hardening actions recommended.\n\n')
    for (const note of notes) {
      write(`  Note: ${note}\n`)
    }
    if (notes.length > 0) write('\n')
    return 0
  }

  write('\n  Planned actions:\n')
  for (const action of actions) {
    const prefix = action.scope === 'project' ? '  [project]' : '  [system]'
    write(`${prefix} ${action.title}\n`)
    for (const p of action.paths) {
      write(`           - ${p}\n`)
    }
  }

  for (const note of notes) {
    write(`\n  Note: ${note}\n`)
  }
  write('\n')

  if (options.apply !== true) {
    write("  Run 'npx sapper-ai harden --apply' to apply project changes.\n")
    write("  Add '--include-system' to include system changes.\n\n")
    return 0
  }

  const canPrompt = isInteractivePromptAllowed({ ...options, env })
  if (!options.yes && !canPrompt) {
    write("  Refusing to apply changes without confirmation. Use '--yes' (and '--include-system' for system).\n\n")
    return 1
  }

  const projectActions = actions.filter((a) => a.scope === 'project')
  const systemActions = actions.filter((a) => a.scope === 'system')

  let applyProject = options.yes === true
  if (!applyProject && projectActions.length > 0) {
    applyProject = await promptYesNo('Apply project changes now?', true)
  }

  if (applyProject) {
    for (const action of projectActions) {
      write(`  Applying: ${action.title}\n`)
      try {
        await action.apply()
      } catch (error) {
        const msg = error instanceof Error ? error.message : String(error)
        write(`  Error applying action (${action.id}): ${msg}\n\n`)
        return 1
      }
    }
    write('  Project hardening complete.\n')
  } else {
    write('  Skipped project changes.\n')
  }

  if (options.includeSystem !== true || systemActions.length === 0) {
    write('\n')
    return 0
  }

  // Two-stage confirmation: system writes are confirmed separately.
  let applySystem = options.yes === true
  if (!applySystem) {
    applySystem = await promptYesNo('Also apply system changes (writes to your home directory)?', true)
  }

  if (!applySystem) {
    write('  Skipped system changes.\n\n')
    return 0
  }

  for (const action of systemActions) {
    write(`  Applying: ${action.title}\n`)
    try {
      await action.apply()
    } catch (error) {
      const msg = error instanceof Error ? error.message : String(error)
      write(`  Error applying action (${action.id}): ${msg}\n\n`)
      return 1
    }
  }
  write('  System hardening complete.\n\n')
  return 0
}
